---
import "./shark-background.css";
---

<div class="sharkBGContainer">
	<div class="lighting"></div>
	<div class="sharkBG" style={{ backgroundColor: "var(--primary)" }}>
		<!-- Waves -->
		<div
			data-height="200"
			data-amplitude="300"
			data-speed="0.06"
			data-points="2"
			style={{
				height: "50%",
				width: "100%",
				position: "absolute",
				top: 0,
				transform: "rotate(180deg) scaleX(-1)",
			}}
		>
			<svg
				width="100%"
				height="100%"
				version="1.1"
				xmlns="http://www.w3.org/2000/svg"
			>
				<path id="wave1" d="" fill="#000"></path>
			</svg>
		</div>
		<div
			id="particles"
			style={{ height: "100vh", width: "100vw" }}
			class="particlesContainer"
		>
		</div>
		<!-- <Particles
        height={"100vh"}
        width={"100vw"}
        class="particlesContainer"
        params={particlesParams}
        particlesRef={particlesRef}
      /> -->
	</div>
</div>

<script>
	var wave = document.getElementById("wave1");
	var width = wave!.parentElement!.parentElement!.getBoundingClientRect().width;
	var height =
		wave!.parentElement!.parentElement!.getBoundingClientRect().height;

	var waveWidth =
		wave!.parentElement!.parentElement!.getBoundingClientRect().width; // Wave SVG width (usually container width)
	var waveHeight = 400; // Position from the top of container
	var waveDelta = 20; // Wave amplitude
	var speed = 1.1; // Wave animation speed
	var wavePoints = 6; // How many point will be used to compute our wave

	function calculateWavePoints(factor: number) {
		var points: Array<{ x: number; y: number }> = [];

		for (var i = 0; i <= wavePoints; i++) {
			var x = (i / wavePoints) * waveWidth;
			var sinSeed = (factor + (i + (i % wavePoints))) * speed * 100;
			var sinHeight = Math.sin(sinSeed / 100) * waveDelta;
			var yPos = Math.sin(sinSeed / 100) * sinHeight + waveHeight;
			points.push({ x: x, y: yPos });
		}

		return points;
	}

	function buildPath(points: Array<{ x: number; y: number }>) {
		var SVGString = "M " + points[0]!.x + " " + points[0]!.y;

		var cp0 = {
			x: (points[1]!.x - points[0]!.x) / 2,
			y:
				points[1]!.y -
				points[0]!.y +
				points[0]!.y +
				(points[1]!.y - points[0]!.y),
		};

		SVGString +=
			" C " +
			cp0.x +
			" " +
			cp0.y +
			" " +
			cp0.x +
			" " +
			cp0.y +
			" " +
			points[1]!.x +
			" " +
			points[1]!.y;

		var prevCp = cp0;
		var inverted = -1;

		for (var i = 1; i < points.length - 1; i++) {
			var cp1 = {
				x: points[i]!.x - prevCp.x + points[i]!.x,
				y: points[i]!.y - prevCp.y + points[i]!.y,
			};

			SVGString +=
				" C " +
				cp1.x +
				" " +
				cp1.y +
				" " +
				cp1.x +
				" " +
				cp1.y +
				" " +
				points[i + 1]!.x +
				" " +
				points[i + 1]!.y;
			prevCp = cp1;
			inverted = -inverted;
		}

		SVGString += " L " + width + " " + height;
		SVGString += " L 0 " + height + " Z";
		return SVGString;
	}

	var lastUpdate: number;
	var totalTime = 0;

	function tick() {
		var now = window.Date.now();

		if (lastUpdate) {
			var elapsed = (now - lastUpdate) / 1000;
			lastUpdate = now;

			totalTime += elapsed;

			var factor = totalTime * Math.PI;
			wave!.setAttribute("d", buildPath(calculateWavePoints(factor)));
		} else {
			lastUpdate = now;
		}

		window.requestAnimationFrame(tick);
	}
	tick();
</script>

<script>
	import { tsParticles } from "tsparticles-engine";
	import { loadBaseMover } from "tsparticles-move-base";
	import { loadImageShape } from "tsparticles-shape-image";
	import { loadSizeUpdater } from "tsparticles-updater-size";
	import { loadOpacityUpdater } from "tsparticles-updater-opacity";
	import { loadColorUpdater } from "tsparticles-updater-color";
	import { loadExternalRepulseInteraction } from "tsparticles-interaction-external-repulse";
	import { loadExternalBubbleInteraction } from "tsparticles-interaction-external-bubble";

	await loadBaseMover(tsParticles);
	await loadImageShape(tsParticles);
	await loadSizeUpdater(tsParticles);
	await loadOpacityUpdater(tsParticles);
	await loadColorUpdater(tsParticles);
	await loadExternalBubbleInteraction(tsParticles);
	await loadExternalRepulseInteraction(tsParticles);

	const prefersReducedMotion = false;

	tsParticles.load("particles", {
		particles: {
			number: {
				value: 30,
				density: {
					enable: true,
					value_area: 800,
				},
			},
			color: {
				value: "#000",
			},
			opacity: {
				value: 1,
				random: true,
				anim: {
					enable: false,
					speed: 1,
					opacity_min: 0.1,
					sync: false,
				},
			},
			shape: {
				type: "image",
				image: {
					src: "/bubble.png",
					width: 64,
					height: 64,
				},
			},
			size: {
				value: 20,
				random: true,
				anim: {
					enable: false,
					speed: 10,
					size_min: 10,
					sync: false,
				},
			},
			line_linked: {
				enable: false,
			},
			move: {
				enable: !prefersReducedMotion,
				speed: 1,
				random: true,
				direction: "top",
				out_mode: "out",
				bounce: false,
			},
		},
		interactivity: {
			detect_on: "window",
			events: {
				onhover: {
					enable: !prefersReducedMotion,
					mode: "repulse",
				},
			},
			modes: {
				bubble: {
					distance: 600,
					size: 30,
					duration: 0.1,
					opacity: 1,
					speed: 300,
				},
				repulse: {
					distance: 20,
					duration: 1,
					speed: 0.2,
				},
			},
		},
	});
</script>
